## 值

#### 原始值类型

原始值的集合是固定的，不可以像对象一样自定义属性，在获取未知属性时会直接返回undefined

##### 数字中的一些特殊值

* NAN	错误值，出现无法转换成数字的情况时出现
* Infinity    分正负，数字过大导致溢出时出现
* 0        JavaScript有两个零，+0 和 -0

> js引擎通常不让你看到它们，并简单将两个零都显示为0，因此最好假装只有一个零(笑)

#### 对象

非原始值都是对象，正则表达式也属于对象

对象之间比较的是其引用

in 操作符用来检测一个属性是否存在(返回值为Boolean)

##### undefined和null的区别

> undefined的意思是“没有值（no value）”。未初始化的变量是undefined
>
> null的意思是“没有对象（no object）”。它被用来表示对象的无值（参数，链上的对象等）

默认undefined、null、NAN以及空字符串都会被判定为false

##### 引用对象中的方法

如果引用一个方法，它将失去和对象的连接(即this不再表示原本的对象)。就其本身而言，函数不是方法，其中的this值为undefined（严格模式下）。

可通过bind方法将新函数的this绑定只对象上

```
var func2 = jane.describe.bind(jane);
```

##### 在方法中嵌入函数

由于this的范围，方法中嵌入的函数使用this不能获取到对象中的内容，可以在函数中声明一个新的变量对外层的this进行承接,如在方法中声明一that(值为this的引用)，就可以在方法的函数中通过that获取到对象的内容

#### 包装类型

> 实际上，每当读取一个基本类型值得时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

~~这就是为什么数组或者字符串会有三种声明方式且不同方式产生的类型可能会不相同~~

这段说错了，这段的原因在原型链

~~建议声明原始值类型不要去new，也不要用函数的形式声明(*用函数返回原始值类型哪有直接声明原始值类型来的方便*)，直接声明，然后调用方法时让计算机来包装成对象就可以了~~

> 引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能再运行时为基本类型值添加属性和方法。

#### 类型的判断

通过**typeof**可以区分出一部分的变量类型（数组，字符串等类型都是object）

剩余的类型可以通过**instanceof**来进行区分，如

```  
var a = {};
alert(a instanceof object);	//true
var b = [];
alert(b instanceof Array);	//true
```

> null的类型是“object”。这是一个bug，但从没被修复，因为修复后会破坏现有的代码

#### 作用域和闭包

JS中变量没有块级作用域，其作用域为整个函数(内部函数甚至可以访问外部的变量)，同时，由于变量提升，应当尽量在函数顶部声明变量

##### 闭包

> 闭包是一个能够访问其他函数作用域的函数。

闭包指的不是封闭内部状态，而是封闭外部状态，为了封闭外部状态，内部函可以记住并访问所在的词法作用域，并且保持着对词法作用域的引用，即使函数是在当前作用域之外执行。也就是说，即使在外部范围失效的时候，仍然会有一份保留在内部状态里面(被称为[自由变量])

一个典型的例子：

```
function outer () {
	var local = 2;
	function inner () {
		return local += 2;
	}
	return inner;
}

var fn = outer();
console.log(fn());	//4
console.log(fn());	//6
```

原因就在于outer是inner的父函数，而inner被赋给了一个全局变量，这导致inner始终在内存中，而inner的存在依赖于outer，因此outer也始终在内存中，不会在调用结束后，被垃圾回收机制回收，闭包延长了函数的生命周期。

##### IIFE：模拟块级作用域

```
(function () {
    statements
})();
```

>主要包含两部分。第一部分是包围在圆括号运算符() 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域
>
>第二部分再一次使用()创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。

此操作可以阻止该匿名函数被解析成函数声明，函数表达式可以被立即调用

## 函数

#### 函数参数

##### 函数的可选参数

> 如果左侧是真值（除了：null，undefined 等）操作符返回左侧数据。否则，它返回第二个操作数

```
function getEvent (event) {
    //获取事件
    return event || window.event;
}
```

可以通过可选参数解决一些兼容性问题

##### arguments

arguments属于类数组，其有一部分数组的特性，但是无法调用数组的方法

可以通过`[].clice.call()`转化成数组：

```
function toArray(arrayLikeObject) {
    return [].slice.call(arrayLikeObject);
}			//call的功能为调用函数并且改变函数的内部指向
					//即赋予类数组一个slice方法
```

#### 异常处理

```
function throwException() {
    throw new Error('Problem!');
}

try {
    throwException();
} 
catch (e) {
    console.log(e);  // 错误信息
    console.log(e.stack);  // 非标准,但大部分浏览器支持
}
```

可以将易出现异常的代码包裹在try中，当代码抛出异常，catch就可以捕获并显示

#### 构造函数

```
// 设置实例数据
function Point(x, y) {
    this.x = x;
    this.y = y;
}
// 方法
Point.prototype.dist = function () {
    return Math.sqrt(this.x*this.x + this.y*this.y);
};
```

> 首先，Point函数设置实例数据。其次，Point.prototype属性包含对象的方法。

> 前者的数据是每个实例私有的，后面的数据是所有实例共享的。

```
var p = new Point(3, 5);
> p.x
3
> p.dist()
5.830951894845301
```

```
>p instanceof Point
true
> typeof p
'object'
```

这时，Point可以被认为是一个类型，所有new出来的对象均为Point的一个实例(有点类的感觉了)

## 严格模式

​	对于部分错误操作(如给字符串强制改变length属性)，js编译器会静默失败(即不弹出错误且不进行操作)

使用严格模式`"use strict"`可以使其及时弹出错误，阻止自动创建全局变量，规范this的使用.

​	尽管如此，仍不建议全局使用严格模式，因为在开发中可能会引入他人的代码，此时使用严格模式可能会弹出一些莫名其妙的错误.

## 正则表达式

正则表达式是描述字符模式的**对象**，常用于模式匹配、文本检索、替换

#### 常用方法

* Exp.test()，检查字符串是否存在与该正则匹配的部分
* Exp.exec()，获取满足条件的片段(以数组的形式)
* string.replace(Exp, Exp)，通过正则替换
* string.match(Exp)，返回所有满足正则的值(数组)
* string.search(Exp)，返回满足的部分所在的下标
* string.split(Exp)，对数组进行正则形式的分割(更多用来将string转化成array)

## 事件

#### 事件委托

> 事件委托的执行步骤      
>
> 找到当前节点的父节点
>
> 将事件添加到父节点上
>
> 判断触发对象是否是想要的触发对象，然后进行后续操作

>事件委托可以减少对空间的占用，同时可以让新建对象可以使用现有方法

```
ul.onclick = function (ev) {
	var e = ev || window.event;        
    var target = e.target || window.event.srcElement;
    if(target.nodeName.toLowerCase() === 'li') {
      target.style.backgroundColor = 'red';
    }          
}			//      可以理解为li委托ul将自身变成红色
```

#### 事件监听器

>传统的事件绑定在重复添加事件时会发生相互覆盖

> 事件监听器的引入可以同时给事件添加多个方法，还可以实现精确删除某一个方法

一点点想法：

​	虽然添加事件监听器可以通过在绑定事件的函数里嵌套多个函数来实现，但是会显得比较杂乱，且不符合`一个函数仅实现一个功能`的原则，使用事件监听器可以增强代码的可读性，同时降低调试难度(大概)